# Generated by Django 2.1.7 on 2019-07-16 18:37

from django.db import migrations, models, transaction
import django.db.models.deletion
import project.models
from django.conf import settings
from django.core.management import call_command
from itertools import chain
from html import unescape
from django.utils.html import strip_tags
import os


LABELS = [
    # 0: Database
    {'Background': 'background',
    'Methods': 'methods',
    'Data Description': 'content_description',
    'Usage Notes': 'usage_notes',
    'Release Notes': 'release_notes',
    'Acknowledgements': 'acknowledgements',
    'Conflicts of Interest': 'conflicts_of_interest'},
    # 1: Software
    {'Background': 'background',
    'Software Description': 'content_description',
    'Technical Implementation': 'methods',
    'Usage Notes': 'usage_notes',
    'Release Notes': 'release_notes',
    'Installation and Requirements': 'installation',
    'Acknowledgements': 'acknowledgements',
    'Conflicts of Interest': 'conflicts_of_interest'},
    # 2: Challenge
    {'Objective': 'background',
    'Participation': 'methods',
    'Data Description': 'content_description',
    'Evaluation': 'usage_notes',
    'Release Notes': 'release_notes',
    'Acknowledgements': 'acknowledgements',
    'Conflicts of Interest': 'conflicts_of_interest'},
    # 3: Model
    {'Background': 'background',
    'Model Description': 'content_description',
    'Technical Implementation': 'methods',
    'Usage Notes': 'usage_notes',
    'Release Notes': 'release_notes',
    'Installation and Requirements': 'installation',
    'Acknowledgements': 'acknowledgements',
    'Conflicts of Interest': 'conflicts_of_interest'}
]


def load_fixture(apps, schema_editor):
    project_types_fixtures = os.path.join(settings.BASE_DIR, 'project',
        'fixtures', 'project-sections.json')
    call_command('loaddata', project_types_fixtures) 


def unload_fixture(apps, schema_editor):
    model = apps.get_model("project", "ProjectSection")
    model.objects.all().delete()


def migrate_content(apps, schema_editor):
    section_model = apps.get_model("project", "ProjectSection")
    # Gets all projects currently in the database
    data = chain(
        apps.get_model("project", "ActiveProject").objects.all(),
        apps.get_model("project", "PublishedProject").objects.all(),
        apps.get_model("project", "ArchivedProject").objects.all()
        )

    for d in data:
        # Separates labels for one resource type
        labels = LABELS[d.resource_type.id]

        # Get SectionContent model according to project status
        model = d._meta.model_name.replace("project", "").capitalize()
        content_model = apps.get_model("project", model+"SectionContent")

        # Persists new SectionContent entity based on content from the previous structure
        sections = section_model.objects.filter(title__in=labels.keys(), resource_type=d.resource_type.id)
        for section in sections:
            l = labels[section.title]
            value = d._meta.get_field(l).value_from_object(d)
            text = unescape(strip_tags(value))

            # Do nothing if empty
            if not text or text.isspace():
                continue
            
            with transaction.atomic():
                content_model.objects.create(project=d, project_section=section,
                    section_content=value)


def undo_migrate_content(apps, schema_editor):
    data = chain(
        apps.get_model("project", "ActiveProject").objects.all(),
        apps.get_model("project", "PublishedProject").objects.all(),
        apps.get_model("project", "ArchivedProject").objects.all()
        )

    for d in data:
        # Separates labels for one resource type
        labels = LABELS[d.resource_type.id]

        # Get SectionContent model according to project status
        model = d._meta.model_name.replace("project", "").capitalize()
        content_model = apps.get_model("project", model+"SectionContent")

        # Persists new SectionContent entity based on content from the previous structure
        project_content = content_model.objects.filter(project=d)
        for pc in project_content:
            value = pc.section_content
            title = pc.project_section.title
            l = labels[title]
            with transaction.atomic():
                setattr(d, l, value)
                d.save()


class Migration(migrations.Migration):

    dependencies = [
        ('project', '0041_auto_20200317_0834'),
    ]

    operations = [
        migrations.CreateModel(
            name='ProjectSection',
            fields=[
                ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('title', models.CharField(max_length=30)),
                ('html_id', models.SlugField(max_length=30)),
                ('description', models.TextField()),
                ('default_order', models.PositiveSmallIntegerField()),
                ('required', models.BooleanField()),
                ('resource_type', models.ForeignKey(db_column='resource_type', on_delete=django.db.models.deletion.PROTECT, related_name='projectsections', to='project.ProjectType')),
            ],
        ),
        migrations.RunPython(load_fixture, reverse_code=unload_fixture),
        migrations.CreateModel(
            name='ActiveSectionContent',
            fields=[
                ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('section_content', project.models.SafeHTMLField(blank=True)),
                ('project', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='project_content', to='project.ActiveProject')),
                ('project_section', models.ForeignKey(db_column='project_section', on_delete=django.db.models.deletion.PROTECT, related_name='activesectioncontents', to='project.ProjectSection')),
            ],
        ),
        migrations.CreateModel(
            name='ArchivedSectionContent',
            fields=[
                ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('section_content', project.models.SafeHTMLField(blank=True)),
                ('project', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='project_content', to='project.ArchivedProject')),
                ('project_section', models.ForeignKey(db_column='project_section', on_delete=django.db.models.deletion.PROTECT, related_name='archivedsectioncontents', to='project.ProjectSection')),
            ],
        ),
        migrations.CreateModel(
            name='PublishedSectionContent',
            fields=[
                ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('section_content', project.models.SafeHTMLField(blank=True)),
                ('project', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='project_content', to='project.PublishedProject')),
                ('project_section', models.ForeignKey(db_column='project_section', on_delete=django.db.models.deletion.PROTECT, related_name='publishedsectioncontents', to='project.ProjectSection')),
            ],
        ),
        migrations.RunPython(migrate_content, reverse_code=undo_migrate_content),
        migrations.AlterUniqueTogether(
            name='activesectioncontent',
            unique_together={('project', 'project_section')},
        ),
        migrations.AlterUniqueTogether(
            name='archivedsectioncontent',
            unique_together={('project', 'project_section')},
        ),
        migrations.AlterUniqueTogether(
            name='publishedsectioncontent',
            unique_together={('project', 'project_section')},
        ),
        migrations.AlterUniqueTogether(
            name='projectsection',
            unique_together={('resource_type', 'title'), ('resource_type', 'html_id'), ('resource_type', 'default_order')},
        ),
    ]
